<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universo Hologr√°fico para Rosario ‚ù§Ô∏è</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        #info { 
            position: absolute; top: 10px; left: 10px; color: white; z-index: 100; 
            background: rgba(0,0,0,0.4); padding: 15px; border-radius: 10px; max-width: 350px;
        }
        #musicBtn { 
            position: absolute; top: 10px; right: 10px; z-index: 100; 
            background: rgba(255,105,180,0.8); color: white; border: none; 
            padding: 12px 20px; border-radius: 50px; cursor: pointer; font-size: 18px; font-weight: bold;
        }
        #floatingMessage {
            position: absolute; top: 20%; left: 5%; transform: translateY(-50%);
            color: #ff69b4; font-size: 32px; font-weight: bold; text-align: left;
            opacity: 0; pointer-events: none; z-index: 50; text-shadow: 0 0 10px #ff1493;
            max-width: 30%; transition: opacity 1.5s;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <h2>üåå Nuestro Universo, mi Rosario ‚ù§Ô∏è</h2>
        <p>Usa WASD para moverte, mouse para mirar. Ac√©rcate a los planetas o mira al fondo para ver la comparaci√≥n de tama√±os.</p>
        <p>¬°Feliz San Valent√≠n, mi amor eterno! üíï</p>
        <button id="musicBtn" onclick="toggleMusic()">‚ñ∂Ô∏è Love Story</button>
    </div>

    <div id="floatingMessage"></div>

    <audio id="bgMusic" loop>
        <source src="https://archive.org/download/indilamusicoggvorbis/Mini%20World/Indila%20-%20Love%20story.mp3" type="audio/mpeg">
        Tu navegador no soporta audio.
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000022, 0.00012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());
        document.addEventListener('click', () => controls.lock());

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Sol
        const sun = new THREE.Mesh(
            new THREE.SphereGeometry(6, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffff88 })
        );
        scene.add(sun);
        const sunLight = new THREE.PointLight(0xffffff, 4, 0);
        sun.add(sunLight);

        // Planetas fijos con rotaci√≥n propia
        const planets = [];
        const msgMeshes = [];
        const messages = [
            { text: 'Te amo mi princesita hermosa ‚ù§Ô∏è' },
            { text: 'Eres lo mejor que me ha pasado en esta vida üåπ' },
            { text: 'Quiero estar contigo para siempre y por siempre amor üíï' },
            { text: '¬øQuieres ser mi San Valent√≠n? üíù' },
            { text: 'Recuerdas nuestra primera cita? A√∫n me pones nervioso... üòç' },
            { text: 'Prometo cuidarte, amarte y hacerte re√≠r todos los d√≠as üëë' }
        ];
        const planetData = [
            { radius: 1.2, pos: [0, 0, 20], color: 0xc0c0c0, rotSpeed: 0.03, emissive: 0x222222 },
            { radius: 1.8, pos: [40, 0, 0], color: 0xff4500, rotSpeed: 0.025, emissive: 0x331100 },
            { radius: 5, pos: [0, 0, -60], color: 0xd8ca9d, rotSpeed: 0.015, emissive: 0x443300 },
            { radius: 2.2, pos: [-15, 0, 0], color: 0x6b93d6, rotSpeed: 0.022, emissive: 0x112244 },
            { radius: 2.5, pos: [0, 15, -45], color: 0xff69b4, rotSpeed: 0.018, emissive: 0x331122 },
            { radius: 4.2, pos: [55, 8, 30], color: 0xe0c080, rotSpeed: 0.012, emissive: 0x443300 }
        ];

        planetData.forEach((data, i) => {
            const planet = new THREE.Mesh(
                new THREE.SphereGeometry(data.radius, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: data.color,
                    emissive: data.emissive,
                    emissiveIntensity: 0.4,
                    roughness: 0.7,
                    metalness: 0.1
                })
            );
            planet.position.set(...data.pos);
            planet.castShadow = true;
            planet.receiveShadow = true;
            scene.add(planet);
            planets.push(planet);

            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,512,256);
            ctx.fillStyle = '#ff69b4'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText(messages[i].text, 256, 140);
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0 });
            const msg = new THREE.Mesh(new THREE.PlaneGeometry(14, 7), mat);
            msg.position.set(data.pos[0], data.pos[1] + 10 + data.radius, data.pos[2]);
            scene.add(msg);
            msgMeshes.push(msg);
            msg.userData.planet = planet;
        });

        // Anillos Saturno
        const ringGeo = new THREE.RingGeometry(5, 7.5, 64);
        const ringMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, side: THREE.DoubleSide, roughness: 0.9 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2 + 0.4;
        planets[5].add(ring);

        // Estrellas
        const starsGeo = new THREE.BufferGeometry();
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
        const verts = [];
        for (let i = 0; i < 30000; i++) {
            verts.push(THREE.MathUtils.randFloatSpread(3000), THREE.MathUtils.randFloatSpread(3000), THREE.MathUtils.randFloatSpread(3000));
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        scene.add(new THREE.Points(starsGeo, starsMat));

        // Constelaci√≥n R y C
        const rcGeo = new THREE.BufferGeometry();
        const rcPositions = [];
        const addPoint = (x, y, z) => rcPositions.push(x, y, z);
        for (let y = -15; y <= 15; y += 1.5) addPoint(-60, y, -500);
        for (let a = 0; a < Math.PI; a += 0.2) addPoint(-60 + Math.cos(a) * 12, 15 - Math.sin(a) * 12, -500);
        for (let i = 0; i < 12; i += 1.5) addPoint(-60 + i, 15 - i*1.2, -500);
        for (let a = Math.PI * 0.2; a < Math.PI * 1.8; a += 0.15) addPoint(50 + Math.cos(a) * 20, Math.sin(a) * 20, -520);
        rcGeo.setAttribute('position', new THREE.Float32BufferAttribute(rcPositions, 3));
        const rcMat = new THREE.PointsMaterial({ color: 0xff69b4, size: 0.6 });
        scene.add(new THREE.Points(rcGeo, rcMat));

        // Gr√°fico comparativo de tama√±os (como la imagen que quieres)
        const loader = new THREE.TextureLoader();
        const comparisonTexture = loader.load('https://science.nasa.gov/wp-content/uploads/2023/09/solar-system-sizes-768.jpg?w=768'); // NASA oficial, comparaci√≥n de tama√±os
        // Alternativa si no carga: 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Solar_sys8.jpg/800px-Solar_sys8.jpg'
        const comparisonMaterial = new THREE.MeshBasicMaterial({ map: comparisonTexture, transparent: true, side: THREE.DoubleSide });
        const comparisonPlane = new THREE.Mesh(new THREE.PlaneGeometry(80, 40), comparisonMaterial); // Tama√±o grande para ver bien
        comparisonPlane.position.set(0, 30, -300); // Lejos al fondo
        scene.add(comparisonPlane);

        // Corazones
        const heartsGeo = new THREE.BufferGeometry();
        const hPos = [], hVel = [], hCol = [];
        for (let i = 0; i < 300; i++) {
            hPos.push(THREE.MathUtils.randFloatSpread(400), THREE.MathUtils.randFloatSpread(200), THREE.MathUtils.randFloatSpread(400));
            hVel.push((Math.random()-0.5)*0.02, Math.random()*0.01+0.003, (Math.random()-0.5)*0.02);
            hCol.push(1, 0.4+Math.random()*0.3, 0.5+Math.random()*0.5);
        }
        heartsGeo.setAttribute('position', new THREE.Float32BufferAttribute(hPos, 3));
        heartsGeo.setAttribute('color', new THREE.Float32BufferAttribute(hCol, 3));
        const heartsMat = new THREE.PointsMaterial({ size: 0.4, vertexColors: true, transparent: true, opacity: 0.7 });
        const hearts = new THREE.Points(heartsGeo, heartsMat);
        scene.add(hearts);

        camera.position.set(0, 12, 50);

        const floatingMsgs = [
            "Nuestro amor es infinito como este universo ‚ù§Ô∏è",
            "Cada estrella brilla por ti, mi R üåü",
            "R y C: unidos en el cosmos para siempre üíç",
            "No hay galaxia que nos separe, mi amor",
            "Eres mi constelaci√≥n, mi universo entero ‚ú®",
            "Te amo m√°s que todas las estrellas juntas üòò"
        ];
        const msgElement = document.getElementById('floatingMessage');
        let lastMsgTime = performance.now();
        const minInterval = 10000;
        const maxInterval = 15000;

        function showRandomMsg() {
            const randomText = floatingMsgs[Math.floor(Math.random() * floatingMsgs.length)];
            msgElement.textContent = randomText;
            msgElement.style.opacity = 0.8;
            setTimeout(() => { msgElement.style.opacity = 0; }, 5000);
        }

        const music = document.getElementById('bgMusic');
        music.volume = 0.25;
        function toggleMusic() {
            if (music.paused) { music.play(); document.getElementById('musicBtn').textContent = '‚è∏Ô∏è Love Story'; }
            else { music.pause(); document.getElementById('musicBtn').textContent = '‚ñ∂Ô∏è Love Story'; }
        }
        document.addEventListener('click', () => { music.play().catch(() => {}); }, { once: true });

        let prev = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - prev) / 1000; prev = now;

            velocity.x -= velocity.x * 10 * delta;
            velocity.z -= velocity.z * 10 * delta;
            direction.z = +moveForward - +moveBackward;
            direction.x = +moveRight - +moveLeft;
            if (direction.length()) direction.normalize();
            if (moveForward || moveBackward) velocity.z -= direction.z * 40 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 40 * delta;
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            sun.rotation.y += 0.0025;

            planets.forEach((p, i) => {
                p.rotation.y += planetData[i].rotSpeed * delta;
            });

            starsGeo.rotateY(0.00003);

            const pos = hearts.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 3) {
                pos[i+1] += hVel[(i/3)*3 +1] * delta * 60;
                if (pos[i+1] > 200) pos[i+1] = -200;
                pos[i] += hVel[(i/3)*3] * 0.3 * delta * 60;
                pos[i+2] += hVel[(i/3)*3 +2] * 0.3 * delta * 60;
            }
            hearts.geometry.attributes.position.needsUpdate = true;

            msgMeshes.forEach(msg => {
                const dist = camera.position.distanceTo(msg.userData.planet.position);
                msg.material.opacity = THREE.MathUtils.lerp(msg.material.opacity, (dist < 18) ? 0.9 : 0, 0.05);
                if (dist < 18) msg.lookAt(camera.position);
            });

            if (now - lastMsgTime > minInterval + Math.random() * (maxInterval - minInterval)) {
                showRandomMsg();
                lastMsgTime = now;
            }

            // El gr√°fico comparativo siempre mira a la c√°mara
            comparisonPlane.lookAt(camera.position);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
