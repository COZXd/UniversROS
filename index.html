<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universo para mi Rosario ‚ù§Ô∏è</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
        #info { 
            position: absolute; top: 10px; left: 10px; color: white; z-index: 100; 
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; max-width: 350px;
        }
        #musicBtn { 
            position: absolute; top: 10px; right: 10px; z-index: 100; 
            background: rgba(255,105,180,0.8); color: white; border: none; 
            padding: 12px 20px; border-radius: 50px; cursor: pointer; font-size: 18px;
        }
        #floatingMessage {
            position: absolute; top: 15%; left: 5%; width: 30%; color: #ff69b4; 
            font-size: 28px; font-weight: bold; text-align: left; opacity: 0; 
            z-index: 50; text-shadow: 0 0 15px #ff1493; transition: opacity 1.5s;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <h2>üåå Universo para mi Rosario ‚ù§Ô∏è</h2>
        <p>Usa WASD para moverte, mouse para mirar alrededor.</p>
        <p>Ac√©rcate a los planetas para ver mensajes especiales.</p>
        <p>¬°Feliz San Valent√≠n, mi princesita hermosa! üíï</p>
        <button id="musicBtn" onclick="toggleMusic()">‚ñ∂Ô∏è Love Story</button>
    </div>

    <div id="floatingMessage"></div>

    <audio id="bgMusic" loop>
        <source src="https://archive.org/download/indilamusicoggvorbis/Mini%20World/Indila%20-%20Love%20story.mp3" type="audio/mpeg">
        Tu navegador no soporta audio.
    </audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000022, 0.0001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011);
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambient);

        const controls = new PointerLockControls(camera, document.body);
        scene.add(controls.getObject());
        document.addEventListener('click', () => controls.lock());

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        document.addEventListener('keydown', e => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', e => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Sol
        const sun = new THREE.Mesh(
            new THREE.SphereGeometry(8, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffffaa })
        );
        sun.position.set(0, 0, 0);
        scene.add(sun);
        sun.add(new THREE.PointLight(0xffffff, 5, 0));

        // Planetas fijos (solo rotan sobre s√≠ mismos)
        const planets = [];
        const msgMeshes = [];
        const planetPositions = [
            { x: 0, z: 30, radius: 1.2, color: 0xc0c0c0, rotSpeed: 0.04 }, // Luna
            { x: 50, z: 0, radius: 2, color: 0xff4500, rotSpeed: 0.03 }, // Marte
            { x: 0, z: -90, radius: 6, color: 0xd8ca9d, rotSpeed: 0.02 }, // J√∫piter
            { x: -40, z: 0, radius: 2.5, color: 0x6b93d6, rotSpeed: 0.035 }, // Tierra
            { x: 0, z: -50, radius: 2.8, color: 0xff69b4, rotSpeed: 0.025 }, // Venus
            { x: 70, z: 40, radius: 5, color: 0xe0c080, rotSpeed: 0.018 } // Saturno
        ];
        const messages = [
            'Te amo mi princesita hermosa ‚ù§Ô∏è',
            'Eres lo mejor que me ha pasado en esta vida üåπ',
            'Quiero estar contigo para siempre y por siempre amor üíï',
            '¬øQuieres ser mi San Valent√≠n? üíù',
            'Recuerdas nuestra primera cita? A√∫n me pones nervioso... üòç',
            'Prometo cuidarte, amarte y hacerte re√≠r todos los d√≠as üëë'
        ];

        planetPositions.forEach((pos, i) => {
            const planet = new THREE.Mesh(
                new THREE.SphereGeometry(pos.radius, 32, 32),
                new THREE.MeshStandardMaterial({
                    color: pos.color,
                    emissive: pos.color,
                    emissiveIntensity: 0.3,
                    roughness: 0.8
                })
            );
            planet.position.set(pos.x, 0, pos.z);
            scene.add(planet);
            planets.push(planet);

            // Mensaje al acercarte
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,512,256);
            ctx.fillStyle = '#ff69b4'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText(messages[i], 256, 140);
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0 });
            const msg = new THREE.Mesh(new THREE.PlaneGeometry(20, 10), mat);
            msg.position.set(pos.x, pos.radius + 8, pos.z);
            scene.add(msg);
            msgMeshes.push(msg);
            msg.userData.planet = planet;
        });

        // Anillos Saturno
        const ringGeo = new THREE.RingGeometry(6, 9, 64);
        const ringMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, side: THREE.DoubleSide });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI / 2 + 0.4;
        planets[5].add(ring);

        // Estrellas
        const starsGeo = new THREE.BufferGeometry();
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.06 });
        const verts = [];
        for (let i = 0; i < 40000; i++) {
            verts.push(THREE.MathUtils.randFloatSpread(4000), THREE.MathUtils.randFloatSpread(4000), THREE.MathUtils.randFloatSpread(4000));
        }
        starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        scene.add(new THREE.Points(starsGeo, starsMat));

        // Constelaci√≥n R y C (lejos al fondo)
        const rcGeo = new THREE.BufferGeometry();
        const rcPositions = [];
        const addPoint = (x, y, z) => rcPositions.push(x, y, z);
        for (let y = -20; y <= 20; y += 2) addPoint(-80, y, -600);
        for (let a = 0; a < Math.PI; a += 0.25) addPoint(-80 + Math.cos(a) * 15, 20 - Math.sin(a) * 15, -600);
        for (let i = 0; i < 15; i += 2) addPoint(-80 + i, 20 - i*1.5, -600);
        for (let a = Math.PI * 0.25; a < Math.PI * 1.75; a += 0.2) addPoint(70 + Math.cos(a) * 25, Math.sin(a) * 25, -620);
        rcGeo.setAttribute('position', new THREE.Float32BufferAttribute(rcPositions, 3));
        const rcMat = new THREE.PointsMaterial({ color: 0xff69b4, size: 0.8 });
        scene.add(new THREE.Points(rcGeo, rcMat));

        // Gr√°fico comparativo de tama√±os (como la imagen que me mostraste)
        const loader = new THREE.TextureLoader();
        const comparisonTexture = loader.load('https://science.nasa.gov/wp-content/uploads/2023/09/solar-system-sizes-768.jpg?w=768');
        const comparisonMat = new THREE.MeshBasicMaterial({ map: comparisonTexture, transparent: true, side: THREE.DoubleSide });
        const comparison = new THREE.Mesh(new THREE.PlaneGeometry(100, 50), comparisonMat);
        comparison.position.set(0, 40, -400);
        scene.add(comparison);

        // Corazones flotantes
        const heartsGeo = new THREE.BufferGeometry();
        const hPos = [], hVel = [], hCol = [];
        for (let i = 0; i < 400; i++) {
            hPos.push(THREE.MathUtils.randFloatSpread(500), THREE.MathUtils.randFloatSpread(300), THREE.MathUtils.randFloatSpread(500));
            hVel.push((Math.random()-0.5)*0.015, Math.random()*0.008+0.002, (Math.random()-0.5)*0.015);
            hCol.push(1, 0.4+Math.random()*0.4, 0.5+Math.random()*0.5);
        }
        heartsGeo.setAttribute('position', new THREE.Float32BufferAttribute(hPos, 3));
        heartsGeo.setAttribute('color', new THREE.Float32BufferAttribute(hCol, 3));
        const heartsMat = new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true, opacity: 0.8 });
        const hearts = new THREE.Points(heartsGeo, heartsMat);
        scene.add(hearts);

        camera.position.set(0, 10, 60);

        const floatingMsgs = [
            "Nuestro amor es infinito como este universo ‚ù§Ô∏è",
            "Cada estrella brilla por ti, mi R üåü",
            "R y C: unidos en el cosmos para siempre üíç",
            "No hay galaxia que nos separe, mi amor",
            "Eres mi constelaci√≥n, mi universo entero ‚ú®",
            "Te amo m√°s que todas las estrellas juntas üòò"
        ];
        const msgElement = document.getElementById('floatingMessage');
        let lastMsgTime = performance.now();
        const minInterval = 10000;
        const maxInterval = 15000;

        function showRandomMsg() {
            const text = floatingMsgs[Math.floor(Math.random() * floatingMsgs.length)];
            msgElement.textContent = text;
            msgElement.style.opacity = 0.85;
            setTimeout(() => msgElement.style.opacity = 0, 6000);
        }

        const music = document.getElementById('bgMusic');
        music.volume = 0.3;
        function toggleMusic() {
            if (music.paused) {
                music.play();
                document.getElementById('musicBtn').textContent = '‚è∏Ô∏è Love Story';
            } else {
                music.pause();
                document.getElementById('musicBtn').textContent = '‚ñ∂Ô∏è Love Story';
            }
        }
        document.addEventListener('click', () => music.play().catch(() => {}), { once: true });

        let prev = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - prev) / 1000;
            prev = now;

            velocity.x -= velocity.x * 10 * delta;
            velocity.z -= velocity.z * 10 * delta;
            direction.z = +moveForward - +moveBackward;
            direction.x = +moveRight - +moveLeft;
            if (direction.length()) direction.normalize();
            if (moveForward || moveBackward) velocity.z -= direction.z * 40 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 40 * delta;
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            sun.rotation.y += 0.002;

            planets.forEach(p => p.rotation.y += 0.01);

            const pos = hearts.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 3) {
                pos[i+1] += hVel[(i/3)*3 +1];
                if (pos[i+1] > 300) pos[i+1] = -300;
                pos[i] += hVel[(i/3)*3] * 0.4;
                pos[i+2] += hVel[(i/3)*3 +2] * 0.4;
            }
            hearts.geometry.attributes.position.needsUpdate = true;

            msgMeshes.forEach(msg => {
                const dist = camera.position.distanceTo(msg.userData.planet.position);
                msg.material.opacity = dist < 20 ? 0.9 : 0;
                if (dist < 20) msg.lookAt(camera.position);
            });

            comparison.lookAt(camera.position);

            if (now - lastMsgTime > minInterval + Math.random() * (maxInterval - minInterval)) {
                showRandomMsg();
                lastMsgTime = now;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
